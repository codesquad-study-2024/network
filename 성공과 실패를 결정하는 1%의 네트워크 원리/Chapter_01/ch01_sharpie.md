## 챕터 1 - 웹 브라우저가 메시지를 만든다
### HTTP 리퀘스트 메시지를 작성한다
#### URL
- http, ftp, file, mailto 등으로 시작 
- 브라우저는 몇 개의 클라이언트 기능을 겸비한 복합적인 클라이언트 소프트웨어 
- 웹 서버에 액세스하는 방법이 여러가지기 때문에 여러 종류의 URL 준비되어 있음 
- 웹 서버 접속이라면 HTTP 프로토콜을 사용하여 액세스. 이렇게 맨 앞에 적힌 액세스 방법에 따라 그 뒤에 계속해서 쓰는 방법이 결정

##### 예시
```
# http
http://user:password@www.cyber.co.kr:80/dir/file1.html

# ftp
ftp://user:password@ftp.cyber.co.kr:21/dir/file1.htm

# file(클라이언트 PC 자체 파일)
file://localhost/c:/path/file1.zip

# mail 송신
mailto:tone@cyber.co.kr

# 뉴스그룹 기사 읽기
news:comp.protocols.tcp-ip
```

#### URL 해독
- 브라우저에 URL을 입력했다면, 이 URL을 해독해야 한다 
- 요소를 따로따로 분해해서 분석한다.

```
http: + // + 웹 서버명 + / + 디렉토리명 + / + ... + 파일명
```
- URL의 맨 앞에는 데이터 출처에 액세스하는 방법, 프로토콜을 기록
- //는 나중에 이어지는 문자열이 서버의 이름임을 나타냄
- 웹 서버명 뒤 부분은 데이터 출처(파일)의 경로명을 나타냄 (생략 가능)

ex) `http://www.lab.cyber.co.kr/dir1/file1.html`
- `www.lab.cyber.co.kr`라는 웹 서버에서 `/dir1/file1.html`라는 경로의 파일, 즉 dir1 디렉토리의 `file1.html` 파일에 액세스

#### 파일명 생략
- `/`로 끝나는 URL 
- 파일명을 쓰지 않으면 어느 파일에 액세스해야 할지 알 수 없음 
- 따라서 이를 대비해 파일명을 미리 서버측에 설정. **index.html, default.htm** 
- `/`를 생략하는 방식도 인정

##### 미묘한 경우
`http://www.lab.cyber.co.kr/whatisthis`

-> 파일명으로 보는 것이 맞을까? 하지만 /를 생략하는 경우도...

=> 웹 서버에 whatisthis라는 파일이 있으면 파일명, 디렉토리가 있으면 디렉토리명으로 판단 (디렉토리도 파일, 같은 이름의 파일은 존재할 수 없으므로)

#### HTTP
- 클라이언트 --- 리퀘스트 메시지 ---> 서버 
- 리퀘스트 메시지가 웹 서버에 도착하면 웹 서버는 그 속에 쓰여있는 내용을 해독하고, URI와 메시지를 조사해 '무엇을', '어떻게' 하는지 판단하고 요구에 따라 동작
- 결과 데이터를 응답 메시지에 저장
- 서버 --- 응답 메시지 ---> 클라이언트
- 응답 메시지 안에서 데이터를 추출하여 화면에 표시하면서 HTTP 동작 끝.

##### 리퀘스트 메시지
- 무엇을 : URI - 페이지 데이터를 저장한 파일의 이름, CGI 프로그램(웹 서버 소프트웨어에서 호출하는 프로그램)의 파일명, http:로 시작하는 URL => 액세스 대상을 통칭
- 어떻게 : 메소드 - 이 메소드에 의해 웹 서버에 어떤 동작을 하고 싶은지를 전달 => URI로 나타낸 데이터를 읽고싶다거나, 클라이언트측에서 입력한 데이터를 URI로 나타낸 프로그램에 전달하고 싶다거나

+) 헤더 파일(보충 정보), 데이터

##### 응답 메시지
- 스테이터스 코드 : 실행 결과가 정상 종료되었는지, 이상이 발생했는지 맨 앞부분에 기록
- 헤더 파일과 페이지의 데이터가 이어지고, 이 메시지가 반송됨

#### HTTP 리퀘스트 메시지
![image](https://gist.github.com/user-attachments/assets/aad2d12e-e66b-4eb3-83b5-bbfc9cedc0d4)
[이미지 출처](https://developer.mozilla.org/ko/docs/Web/HTTP/Messages)

메소드 URI HTTP버전 - 리퀘스트 라인 <br>
필드명 : 필드값 - 메시지 헤더(한 행에 한 개의 헤더 필드) <br>
... <br>
<공백 행> <br>
메시지 본문 - 클라이언트에서 서버에 송신하는 데이터. (주로 POST) <br>
---
HTTP 버전 스테이터스 코드 응답 문구 <br>
필드명 : 필드값 <br>
... <br>
<공백 행> <br>
메시지 본문 - 서버에서 클라이언트에게 송신하는 데이터 (바이너리 데이터로 취급) <br>
---

- 웹 페이지에서 하이퍼링크를 누른다던지, 폼에서 send 버튼을 누른다던지 하는 장면에 따라 메소드가 결정된다. 
- 메시지 헤더는 첫 번째 행에서 내용을 대략 알 수 있으나 부가적인 자세한 정보가 필요한 경우 써 두는 역할, 브라우저의 종류나 버전, 설정 등에 따라 내용이 달라지기도. 
- GET인 경우 메시지 본문에 쓰는 데이터는 아무 것도 없다.

#### HTTP 응답 메시지
- 스테이터스 코드 : 숫자로 쓴 것. 프로그램 등에 실행 결과를 알려주는 것이 목적
- 응답 문구 : 문장으로 쓴 것. 사람에게 실행 결과를 알리는 것이 목적
- 본문 : 영상 등을 포함한 경우 영상을 포함하고 있는 의미의 태그를 만나면 그곳에 영상용 공백을 비워두고 문장 표시 <br>
  -> 다시 웹 서버에 액세스해 태그에 쓰여있는 영상 파일을 웹 서버에서 읽어 와 방금 전 비워둔 공백에 표시(페이지 요청 때와 마찬가지로 리퀘스트 메시지 작성)

**※ 리퀘스트 메시지에 쓰는 URI는 한 개만으로 결정. 파일을 한 번에 한 개씩만 읽을 수 있다.** <br>
-> 따라서 따로따로 파일을 읽어야. <br>
-> 이렇게 필요한 파일을 판단하고, 읽어 레이아웃을 정해 화면에 표시하는 상태로 전체의 동작을 조정하는 것도 브라우저의 역할 <br>
-> 웹 서버측은 이 사정을 모르고, 각각 별도의 페이지인지 신경쓰지 않음. 한 개의 리퀘스트에 한 개의 응답만! <br>

### 웹 서버의 IP주소를 DNS 서버에 조회한다
- 브라우저에는 메시지를 네트워크에 송출하는 기능은 x
- HTTP 메시지를 만들면 이것을 OS에 의뢰하여 액세스 대상의 웹 서버에 송신

#### TCP/IP 기본 개념 설명
![image](https://github.com/user-attachments/assets/c5e46bee-a292-4366-875e-10dd1155bcc2)
[이미지 출처](https://avinetworks.com/glossary/subnet-mask/)

- 서브넷은 허브에 몇 대의 PC가 접속된 것으로 생각해도 된다
- 서브넷이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크가 만들어짐
- 네트워크 번호 + 호스트 번호 = 네트워크 주소 를 할당하는데, 이것이 IP 주소
- 송신측이 메시지를 보내면, 서브넷 내의 허브가 운반하고 가장 가까운 라우터까지 도착. 라우터가 메시지를 보낸 상대를 확인해 다음 라우터 판단, 보내도록 지시하여 송신 동작을 실행 후 다시 서브넷의 허브에 라우터까지 메시지 전송. (라우터 + 허브인 기종도 있다 생각하면 됨)
<br> => 반복하면 최종적으로 도착

#### IP 주소
- 32비트 디지털 데이터
- 1바이트(옥텟, 8비트)씩 점으로 구분해 10진수로 표기
- 어느 부분이 네트워크 번호인지, 호스트 번호인지 알 수 없음 => 사용자가 직접 결정 가능
- 이것을 나타내는 정보를 필요에 따라 IP 주소에 덧붙이는데, 이것이 '넷마스크'

```
10.1.2.3         00001010.00000001.00000010.00000011
255.255.255.0    11111111.11111111.11111111.00000000

10.1.2.          00001010.00000001.00000010
3                                    00000011
```

넷마스크가 1인 부분 => 네트워크 번호 <br>
넷마스크가 0인 부분 => 호스트 번호

##### 표기 방법
10.1.2.3/255.255.255.0 <br>
10.1.2.3/24

-> 서브넷을 나타내는 주소 : 10.1.2.0/24 <br>
-> 서브넷의 브로드캐스트를 나타내는 주소 : 10.1.2.255/24

#### 도메인명
- IP 주소는 기억하기 어렵다. 
- 이름으로 상대를 지정하여 통신? >> IP 주소는 4바이트, 도메인명은 최대 255바이트(RFC 공식문서) <br>
=> 라우터의 부하. 길이가 결정되어있지 않은 데이터 취급이 더 어렵다. 라우터의 속도에는 한계, 효율성이 낮다.

사람은 이름을 사용하고, 라우터는 IP 주소를 사용하는 방법
<br> => DNS

#### 리졸버
- DNS 서버에 조회 메시지를 보내고, 반송되는 응답 메시지(IP주소)를 받기 => **네임 리졸루션**
- DNS 서버에 대한 클라이언트 => **DNS 리졸버**

리졸버의 실체는 Socket 라이브러리에 들어있는 부품화한 프로그램
![image](https://github.com/user-attachments/assets/d9b8c81d-23e0-41eb-a0dd-4901ac19a3a9)
이미지 출처 - 성공과 실패를 결정하는 1%의 네트워크 원리

- 리졸버 호출 => 리졸버에게 제어가 넘어간다 (애플리케이션은 일시 정지)
- 리졸버는 애플리케이션에서 의뢰받은 작업 실행 
- DNS 서버에 문의하기 위한 메시지 만들고, OS 내부 프로토콜 스택(네트워크 제어용 소프트웨어)을 호출해 실행 의뢰. -> 리졸버도 네트워크에 대해 송/수신하는 기능 x 
- 다시 제어가 프로토콜 스택에게 넘어가고, 메시지 보내는 동작 실행해 LAN 어댑터로 메시지가 DNS 서버로 송신 
- DNS 서버는 조회 내용을 조사해 답을 찾아 응답 메시지를 반송 
- 도착한 메시지는 프로토콜 스택을 경유해 리졸버에게 건네짐
- 리졸버는 내용을 해독, IP 주소를 추출해 애플리케이션에게 전달
- 리졸버를 호출할 때 지정한 메모리 영역(을 나타내는 변수)에 IP 주소를 저장
- 이렇게 리졸버 동작이 끝나고 애플리케이션(브라우저)에게 제어가 돌아온다

=> 다층 구조. 상위 계층에서 의뢰 시 그 일을 스스로 전부 실행하지 않고 하위 계층에 실행을 의뢰하며 처리 진행

DNS 서버에 메시지를 송신할 때도 DNS 서버의 IP 주소가 필요한데, 이것은 TCP/IP 설정 항목의 하나하나로 컴퓨터에 미리 설정. 다시 조사할 필요 x

### 전 세계의 DNS 서버가 연대한다
#### 조회 메시지
- 이름 : 서버나 메일 배송 목적지
  - www는 관례가 되었을 뿐 이걸로 시작하지 않아도 됨
- 클래스 : IN (초기에는 인터넷 이외 네트워크도 고려했으나, 현재 인터넷밖에 없음)
- 타입 : A, MX, PTR, CNAME, NS, SOA 등
  - A : address의 약자. IP 주소에 붙인 이름을 나타냄. IP 주소를 할당한 기기의 이름이라고 생각하면 된다.
  - MX : 메일 배송 목적지 의미.
  - PTR(이름 조사 시 사용), CNAME(닉네임 붙이기 위함), NS(DNS의 IP주소 등록), SOA(도메인 자체 속성 정보 등록) ...

DNS 서버에 등록 정보가 설정 파일 등에 입력되어 있음.  <br>
이름, 클래스, 타입에 대응되는 IP 주소 정보 1행을 리소스 레코드 라고 함

##### 리소스 레코드 예시
| 이름 | 클래스 | 타입          | 클라이언트에 회답하는 항목      |
|---|-----|-------------|---------------------|
|www.lab.cyber.co.kr| IN  | A           | 192.0.2.226         |
|cyber.co.kr| IN  | MX          | 10 mail.cyber.co.kr |
|mail.cyber.co.kr| IN  | A| 192.0.2.227 |

- 이렇게 표 형태로 되어있지는 않음 <br>
=> 이름, 클래스, 타입 모두 일치하는 것을 찾아 응답 <br>
=> MX의 경우 메일 서버의 우선순위와 메일 서버 이름이 등록되어 있는데, 이 두 개의 항목에 대해 회답함. 메일 서버가 복수 등록되어 있는 경우 어떤 걸 우선해 선택할지 결정하기 위함(작은 것 우선)

- 조회 메시지를 받은 DNS 서버에 이름과 IP주소가 등록되어 있는 경우를 가정했으나, 인터넷에는 막대한 수의 서버 존재. 이것을 전부 한 대의 DNS 서버에 등록하는 것은 불가능.

#### 도메인 계층
- 도메인명 => 계층적 구조를 가진 이름
- `.`으로 구분하는데, 이 점이 계층을 구분 (점으로 해 두면 계층을 간단히 늘릴 수 있어 유연성 up)
- 하나의 계층이 도메인

#### 웹 페이지 로드와 관련된 4개의 DNS 서버
- Local Domain Name Server (+ DNS Recursor)
- Root Domain Name Server
- Top-Level Domain Name Server
- Autoritative Domain Name Server

#### DNS 서버에서 IP 주소 조회하기
- 전 세계 수만 대의 DNS 서버에서 어떻게 등록한 정보를 찾아내는가?
- 하위의 도메인을 담당하는 DNS 서버의 IP 주소를 그 상위의 DNS 서버에 등록하는 식으로 차례로 등록되어 있음
- 루트 도메인 -> 최상위 도메인(Top-Level Domain) -> ...
  - 루트 도메인의 DNS 서버에 할당된 IP 주소는 전 세계에 13개, 실질적 서버는 7/24 기준 대략 1800개(root-servers.org). AnyCast 기술을 활용해 가장 가까운 루트 DNS 서버로 연결된다
  - TLD의 경우 IANA에서 관리하며, 도메인 확장은 등록이 어렵다(비용이 높고, 절차가 복잡). ko.tld-list.com에서 tld 목록 확인 가능

![image](https://github.com/user-attachments/assets/c78f1b0c-9d56-4ecb-81c2-2cc523518e58)
[이미지 출처](https://devhyena.com/web-%EB%8F%84%EB%A9%94%EC%9D%B8domain%EA%B3%BC-dns-%EA%B0%9C%EB%85%90/)

- 클라이언트 PC는 가장 가까운 DNS 서버, 로컬 DNS 서버에 웹 서버 정보 조회 메시지를 보낸다.
- 로컬 DNS 서버는 ISP(인터넷 서비스 제공자 => 보통 통신사)에서 제공하거나, 조직 내부에 존재하는데, 보통 이 내부에 DNS 리커서가 존재한다. (구글 public dns의 경우를 확인해보면 됨)
- 요청을 받아 DNS 서버 내에 캐싱된 정보가 없으면, DNS 리커서가 재귀적 질의(재귀적 쿼리)를 통해 필요한 정보를 찾아 로컬 DNS 서버에 반환한다
- 재귀적 쿼리는 다음과 같이 진행
  - Root DNS Server에 질의 -> TLD 서버 IP 주소 반환
  - TLD DNS Server에 질의 -> 서브도메인/권한 있는(Authoritative) DNS Server IP 주소 반환

#### 캐시 기능
- 한 대의 DNS 서버에 복수 도메인의 정보를 등록할 수 있어 각 도메인에 한 대의 DNS 서버가 존재한다고 단정 불가
- 현실에는 상위와 하위의 도메인을 같은 DNS 서버에 등록하는 경우도
- DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있는데, 조회한 이름에 해당하는 정보가 캐시에 있으면 그 정보를 회답
- 그럼 그 위치에서 계층 구조를 아래로 향하여 조회 가능.
- 이름이 존재하지 않는다는 결과도 저장 가능
- 저장 후 정보가 변경되는 경우도 있어 유효 기간을 설정(TTL), 지나면 삭제됨
- 조회에 회답할 때 정보가 캐시에 저장된 것인지, 등록처 DNS 서버에서 회답한 것인지 알려줌

##### 루트 DNS 서버와 TLD 서버의 캐싱
- 루트 : TLD에 대한 정보 제공. TLD에 대한 네임서버 주소 캐시
- TLD : 하위 도메인 네임서버 주소에 대한 캐시
- 도메인 자체에 대한 캐싱 => 도메인에 대한 구체적인 IP 주소 정보는 권한 있는 네임서버가 캐시

### 프로토콜 스택에 메시지 송신을 의뢰한다
- IP 주소를 조사했다면, 그 상대에게 메시지를 송신하도록 OS 내부의 프로토콜 스택에 의뢰
- 이때 Socket 라이브러리 프로그램 부품을 결정된 순번대로 호출

```
   클라이언트                  서버
프로토콜 스택(TCP)        프로토콜 스택(TCP)
   LAN 카드                  LAN 카드
    (소켓) ------------------ (소켓)
```
- 데이터를 송/수신하는 컴퓨터 사이 데이터 통로, 파이프 같은 것이 있다고 생각하면 된다
- 이 파이프를 통해 데이터를 교환하는데, 송/수신 전에 그 대상인 양자 사이를 파이프로 연결하는 동작이 필요
- 파이프 양끝의 데이터 출입구 -> 소켓. 이 소켓을 만들고 연결
- 실제로는 서버 쪽에서 소켓을 만들어 소켓에 클라이언트가 파이프를 연결하기를 대기
- 기다리는 동안 클라이언트 측에서도 소켓을 만들고, 소켓에서 파이프를 늘려 서버측 소켓에 연결
- 송/수신 동작이 끝나면 파이프 분리. (어느 쪽에서 분리해도 상관 없다)

**요약**
- 소켓을 만든다(소켓 작성 단계)
- 서버측의 소켓에 파이프를 연결한다(접속 단계)
- 데이터를 송/수신한다(송/수신 단계)
- 파이프를 분리하고 소켓을 말소한다(연결 끊기 단계)

#### 데이터 송/수신을 의뢰하는 애플리케이션 프로그램(브라우저)의 동작

- socket이라는 프로그램 부품 호출 -> 제어가 넘어가 소켓 만드는 동작 실행, 다시 제어가 돌아옴. **디스크립터** 반환
- 디스크립터는 소켓을 식별하기 위한 것
- 이제 프로토콜 스택에 의뢰하는데, connect라는 프로그램 부품을 호출해 의뢰 동작 실행
  - 디스크립터, 서버의 IP 주소, 포트 번호 세 가지 값
- 프로토콜 스택이 통지받은 디스크립터를 보고 어느 소켓을 서버측의 소켓에 접속할지 판단해 접속 동작 실행
- 상대와 연결되면 프로토콜 스택은 여결된 상대의 IP 주소나 포트 번호 등의 정보를 소켓에 기록

#### IP 주소와 포트 번호
- IP 주소 : 네트워크에 존재하는 각 컴퓨터를 식별하기 위해 각각에 서로 다른 값을 할당한 것
- 포트 번호: IP 주소로는 소켓까지 지정할 수 없는데, 포트 번호를 사용하면 어느 컴퓨터의 어느 소켓과 접속할지를 분명히 지정 가능


- 디스크립터는 소켓을 만들도록 의뢰한 애플리케이션에 건네주는 것. 접속 상대에 건네주는 것 x. 접속 상대측에서는 그 값을 모른다
- 서버측 소켓의 디스크립터를 클라이언트에서 알 수 없으므로 클라이언트측에서 서버측의 디스크립터를 사용해 서버측의 소켓 지정 불가능
- 그래서 클라이언트측에 알리는 중간 과정이 필요 -> 포트 번호(접속 상대측에서 소켓을 식별하기 위해 사용)
- 애플리케이션 종류에 따라 미리 결정된 값을 사용한다는 규칙
  - 80 : 웹
  - 25 : 메일
  - ...


- 서버도 클라이언트측의 소켓 번호가 필요할 텐데...
  - 클라이언트 소켓의 포트 번호는 소켓을 만들 때 프로토콜 스택이 적당한 값을 골라 할당
  - 접속 동작을 실행할 때 서버측에 통지됨

#### 메시지를 주고받는 송/수신 단계
##### 송신
- write라는 프로그램 부품을 사용, 디스크립터와 송신 데이터를 지정한다
- 프로토콜 스택이 송신 데이터를 서버에 송신
- 소켓에는 연결 상대가 기록되어 있어 디스크립터로 소켓을 지정하면 연결된 상대가 판명되어 그곳을 향해 데이터를 송신
- 서버는 수신 동작을 실행해 받은 데이터에 대해 처리하고 응답 메시지를 반송

##### 수신
- read라는 프로그램 부품 사용, 프로토콜 스택에 수신 동작 의뢰
- 수신한 응답 메시지를 저장하기 위한 메모리 영역, 수신 버퍼에 응답 메시지를 저장
- 수신 버퍼는 애플리케이션 프로그램 내부에 마련된 메모리 영역이므로 수신 버퍼에 메시지를 저장한 시점에 메시지를 애플리케이션에 건네줌

#### 연결 끊기 단계
- close라는 프로그램 부품 호출해 연결 끊기 단계로 들어가도록 의뢰
- 웹 서버측에서 연결 끊기 동작을 실행 -> 서버 측에서 close로 연결 끊기
- 클라이언트 측에 전달되어 클라이언트 소켓은 연결 끊기 단계로 들어감
- 브라우저가 read로 수신 동작을 의뢰했을 때 read는 수신한 데이터를 건네주는 대신 송/수신 동작이 완료되어 연결이 끊겼다는 사실을 브라우저에 통지
- 브라우저에서도 close를 호출해 연결 끊기 단계 들어감


- HTTP 프로토콜은 HTML 문서나 영상 데이터를 하나하나 별도의 것으로 취급해 1개 데이터를 읽을 때마다 접속, 송신, 수신, 끊기 동작 반복
- 하나의 웹 페이지에 영상이 많으면 여러 번 반복할 것
- 그러나 같은 서버에 복수의 데이터를 읽을 때 접속과 연결 끊기를 반복하는 것은 비효율적
- 한번 접속한 후 연결을 끊지 않고 복수의 리퀘스트와 응답 주고받기를 실행하는 방법도 마련 (HTTP 1.1)
- 이 경우 리퀘스트해야 할 데이터 없어진 상태에서 브라우저에서 연결 끊기 동작 들어가기 가능

