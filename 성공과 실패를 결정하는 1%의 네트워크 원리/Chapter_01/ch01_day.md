## Chapter 01 웹 브라우저가 메시지를 만든다

1장에서는 네트워크 통신 과정의 시작이라고 할 수 있는 웹 브라우저에서 일어나는 동작들에 대해 안내한다.  
브라우저는 리퀘스트 메시지를 생성하고 메시지를 웹 서버로 전송하는데, 엄격히 말하자면 브라우저가 직접 보내는 것은 아니고 OS를 통해 과정이 이루어진다.

### story 1. HTTP 리퀘스트 메시지를 작성한다.
#### URL부터 시작되는 네트워크 여행
브라우저는 웹 서버에 액세스하는 역할 뿐 아니라, FTP나 메일의 클라이언트 역할도 수행할 수 있다.
따라서 이러한 역할들을 수행하기 위해 URL에는 일반적인 http 방식을 비롯한 다양한 형식들이 존재한다.

URL에는 도메인명, 혹은 파일의 경로명이나 메일 주소, 포트 주소 등등이 포함되며, 어떤 것에 액세스할지를 나타내기 위해 맨 앞에 액세스 방법이 명시되어야 한다.
```
# http 프로토콜
http://www.naver.com

# ftp 프로토콜
ftp://ftp.fileserver.co.kr/here/is/file.txt
```
브라우저는 이런 URL을 부분부분 나눠서 해석한다. 예를 들어서 다음과 같은 http 프로토콜 URL은 해당 웹 서버에서 해당 경로의 파일에 액세스하겠다는 의미를 가진다.
```
(http:) + (//) + (www.naver.com) + (/dir/file.txt)
프로토콜 + 서버이름구분자 + 웹서버명 + 파일의 경로명 (경로명은 생략 가능하며, 생략할 경우 일반적으로 index.html 파일로 액세스)
```

#### HTTP 프로토콜이란?
클라이언트와 서버가 주고받는 메시지의 내용과 순서를 약속한 것
리퀘스트 메시지에는 `무엇을`, `어떻게`의 의미를 가지는 URI와 메소드가 포함되어 있고, 그 밖에도 헤더 파일과 같은 보충 데이터들이 포함된다.
- URI : Uniform Resource Identifier의 약자로, 어떤 리소스에 대한 요청인지를 의미. 이는 주로 요청하는 파일명이지만, URL을 그대로 URI로 보기도 한다.
- 메소드 : 어떤 동작을 할 것인지에 관한 것을 의미

| 메소드     | 의미                                |
|---------|-----------------------------------|
| GET     | URI로 지정된 리소스의 값을 요청               |
| POST    | 데이터를 서버로 전송                       |
| HEAD    | 동일 URL로 GET 요청을 보냈을 때의 HEAD 값을 요청 |
| OPTIONS | URL에 허용된 통신 옵션을 조사                |
| PUT     | URI로 지정된 리소스를 생성하거나, 대치 (멱등o)     |
| PATCH   | URI로 지정된 리소스를 부분 수정               |
| DELETE  | URI로 지정된 리소스를 삭제                  |
| TRACE   | 서버로 보낸 요청을 그대로 반환. 주로 디버깅할 때 사용   |
| CONNECT | 메시지를 프록시로 전송                      |

> 더 자세한 내용은 https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods 참조!

이렇게 요청을 보내고 나면 서버에서는 해당 요청을 처리하여 응답을 돌려주는데, 이 때 응답 메시지에는 응답의 결과를 나타내는 상태 코드를 비롯해 결과가 포함된다.

#### 리퀘스트 & 리스폰스 메시지를 좀 더 분석해 봅시다.

리퀘스트 메시지의 첫 번째 행에는 리퀘스트 라인이 들어가야 한다. 여기에는 앞서 언급한 HTTP 메소드가 포함되어야 한다.
그 밑으로는 메시지 헤더들, 그리고 필요한 경우 메시지 본문의 내용들 순서로 구성된다.

```http request
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 49

{
  "name": "day",
  "email": "day@codeSquad.com"
}
```

> 메시지 헤더에 관한 더 자세한 내용은 https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers 참조!

이렇게 리퀘스트를 보내면 리스폰스 응답이 되돌아온다. 리퀘스트의 실행 결과가 첫 줄에 스테이터스 코드와 응답 메시지로 표현되어 있는 것을 볼 수 있다.
응답 코드는 번호대에 따라서 각각 크게 의미를 가지는데, 예를 들면 200번대는 정상 종료. 400번대는 클라이언트 오류. 500번대는 서버 오류 등등

```http request
HTTP/1.1 201 Created
Content-Type: application/json
Content-Length: 109

{
  "id": 3,
  "name": "Kim Yuna",
  "email": "kim.yuna@example.com",
  "age": 30,
  "created_at": "2024-07-23T14:30:00Z"
}
```

응답 메시지는 하나의 리소스에 대한 요청 실행 결과이다. 따라서 여러개의 파일에 대한 액세스가 필요할 경우 그 횟수만큼 요청을 보내게 된다.

예를 들어 페이지를 GET 하는 명령에서 추가적으로 더 읽어와야 할 리소스가 있다면 어떨까? 브라우저는 응답 메시지로 받은 정보를 해석하면서 이렇게 추가적인 요청을 보내야 하는 경우를 캐치하게 된다.  
그렇게 해당 내용을 따라 필요한 만큼 추가적으로 다시 리퀘스트 메시지를 웹 서버에 보낸다. 이런 경우 웹 서버는 이 4번의 리퀘스트가 연속되어 오는 요청인지 별개의 요쳥인지 신경쓰지 않고 한 개의 요청에
한 개의 응답을 돌려보낸다.

### story2. 웹 서버의 IP 주소를 DNS 서버에다 조회한다.

HTTP 리퀘스트 메시지를 만들고 나면 브라우저는 이제 이 메시지를 대상 웹 서버로 보내야 한다. 하지만 브라우저는 네트워크에 직접적으로 메시지를 보낼 수 없기 때문에, 이 부분은 OS가 담당한다.
OS가 대상 웹 서버로 요청을 보내기 위해서는 서버 도메인 주소의 IP 주소가 필요한데, 이를 위해 브라우저는 DNS 서버를 이용하게 된다.

#### 용어
- 허브
- 라우터
- 4개의 옥텟이라는 표현 : 옥텟은 네트워크에서 8비트를 지칭 따라서 그냥 1바이트를 의미하는 표현이다.
- 브로드캐스트 : 서브넷에 있는 기기 전체에 패킷을 보내는 역할을 하는 곳
- 프로토콜 스택

#### TPC/IP 기초 개념
`허브`에 n대의 컴퓨터가 접속하게 되고, 이런 허브가 모여서 `서브넷`(논리적인 네트워크 분할 단위) &rarr; 서브넷을 `라우터`로 접속하여 전체 네트워크가 만들어진다.  
네트워크 주소가 부여될 때, 서브넷은 동(네트워크 번호), 서브넷에 접속되어 있는 컴퓨터들은 각자 번지(호스트 번호)가 부여된다고 생각하자.  

&rarr; 네트워크 번호 + 호스트 번호 = IP 주소!

IP 주소를 식별했으면 그 다음으로..
1. 서브넷 내부 허브를 통해 가장 가까운 라우터로 이동
2. 그리고 도착한 라우터가 다시 주소를 식별, 그 다음으로 가야 할 라우터로 보내도록 지시
3. 다시 동일하게 반복하면서 최종 목적지까지 이동

#### IP 주소 표기법
IP 주소는 32비트로 이루어지며, 이를 1바이트씩 점으로 구분해서 표기한다. &rarr; `10.11.12.13`  
그런데 이러면 이게 네트워크 번호인지 호스트 번호인지 알 방법이 없어서 이를 위해 `넷마스크`라는 정보가 뒤에 추가로 붙게 된다. &rarr; `10.11.12.13/255.255.255.0`
- 넷마스크의 모습을 보면 IP 주소와 동일한 형식으로 생겼다는 것을 알 수 있다. 그렇기 때문에 각 넷마스크는 본인과 동일한 위치에 있는 IP 주소의 정보를 나타낸다.
- 넷마스크는 순서대로 왼쪽부터 채워진다. 1바이트로 나타낼 수 있는 가장 큰 10진수 숫자는 255이기 때문에, 255는 맨 앞 1바이트 자리가 모두 1로 채워진 상태임을 의미한다.
- 그렇다면 1로 채워졌다는 것은 어떤 의미일까? 넷마스크에서 1로 채워져 있다는 것은 동일한 위치의 IP 주소가 네트워크 번호에 속한다는 의미이고, 반대로 0은 호스트 번호에 속한다는 의미이다.
  - 예를 들어 `10.11.12.13/255.255.255.0`은 넷마스크 부분의 3옥텟이 1로, 나머지 1옥텟이 0이기 때문에, `10.11.12.13`에서 네트워크 번호는 `10.11.12`, 호스트 번호는 `13`이라는 의미가 된다.
> 여기서 잠깐 `10.11.12.13/255.255.255.0` 는 축약형으로 `10.11.12.13/24`로 네트워크 번호가 몇 비트나 채워져 있는지로 나타낼 수도 있다.

만약 호스트 번호 부분의 비트가 모두 0(`10.11.12.0/255.255.255.0`)이라면, 서브넷 자체를 나타내고, 호스트 번호 부분의 비트가 모두 1(`10.11.12.255/255.255.255.0`)이라면 서브넷 전체에 대한 `브로드캐스트`를 나타낸다.

#### 그런데 DNS 서버에는 어떻게 요청을 해야 하나요?
브라우저가 도메인 이름으로 실제 ip 주소를 찾기 위해서는 DNS 서버의 도움을 받아야 한다고 했는데, 그렇다면 어떻게 DNS 서버에 요청을 할 수 있는 것일까?
브라우저가 DNS에 요청을 한다는 것은 우리가 클라이언트로 동작한다는 것이다. 이 DNS 클라이언트를 DNS 리졸버 혹은 간단하게 리졸버라고 부르는데, 이 리졸버는 운영체제에서 사용되는 Socket 라이브러리 내부에 들어 있는 프로그램이다.
그리고 이를 통해 IP를 조사하는 행위를 네임 리졸루션이라고 한다.

리퀘스트 메시지가 만들어지고, 리졸버가 작동하게 되는 과정은..
1. 브라우저는 리퀘스트 메시지를 만들고 헤더에 있는 Host 필드를 확인해서 도메인 이름일 경우 ip 주소를 가져오기 위해 동작
2. 브라우저가 OS의 DNS 리졸버를 호출! (제어권은 리졸버로)
3. 마치 브라우저가 웹 서버에 리퀘스트 메시지를 보내듯, 리졸버가 DNS 서버에 주소 조회 메시지를 보낸다.
> 여기서 잠깐 이렇게 메시지를 보내는 것도 리졸버가 스스로 하는 것이 아니고, OS의 `프로토콜 스택`에 부탁해서 보낸다. 리졸버도 브라우저처럼 직접 네트워크로 데이터를 보낼 수 없기 때문에 OS의 도움을 받는 것
4. DNS 서버에서 조사를 한 후, 응답 메시지를 보내준다.
5. 다시 반대로 응답 메시지가 돌아오면서 리졸버가 응답 메시지 안에 있는 IP 주소를 추출해서 지정된 메모리 자리에 넣어 둠
6.(다시 제어권이 브라우저로)이제 브라우저는 메모리에서 IP 주소를 꺼내서 리퀘스트 메시지와 함께 OS에게 전달해서 웹 서버로 보내도록 함

&rarr; 여기서 눈여겨 봐야 할 것은 통신이 다층 구조로 이루어져, 상위 계층에서 하위 계층으로 의뢰하면서 일이 처리되는 방식으로 동작한다는 것

### story3. 전 세계의 DNS 서버가 연대한다
- TDL 서버 : Top-Level Domain, 예를 들어 .com, .org, .net, .edu, .gov 등이 대표적인 TLD
#### DNS 서버의 기본 동작 이해하기
DNS 서버는 `이름`, `클래스`, `타입`이 포함되어 있는 요청 메시지를 받고, 등록된 정보를 조회해서 해당 요청 메시지와 일치하는 IP 주소를 찾은 후 응답한다.

예를 들어 www.naver.com, IN, A 이 포함된 요청 메시지 전송 &rarr; 일치하는 IP인 192.0.2.226 응답

여기서 타입은 말 그대로 요청 정보가 어떤 타입인지를 나타내는 항목이다. A 타입은 도메인 네임을 IPv4로 매핑하라는 의미, MX 타입은 도메인 네임을 메일 서버와 매핑하라는 의미와 같은 식이다.  
클래스는 애초에 인터넷 뿐 아니라 다른 네트워크에서도 DNS가 사용될 것을 예상하고 만들어졌지만, 지금은 인터넷을 의미하는 IN 한 가지만 남게 되었다.

#### DNS 서버는 한 대만 있는 것이 아니다
이제 이러한 정보를 가지고 DNS 서버에 요청을 보내게 되는데, 전 세계에는 수많은 DNS 레코드가 존재하기 때문에 한 대의 서버에 모든 DNS 레코드 정보를 저장할 수는 없다.
따라서 우리가 원하는 IP 정보가 수많은 DNS 서버 중 어떤 서버에 있는지 판별하는 과정이 필요하다. 이 과정을 이해하기 위해 먼저 도메인의 계층부터 알아본다!

#### 도메인에는 계층이 존재한다
DNS 서버에 등록되어 있는 정보에는 `도메인명`이라는 계층적 구조의 이름이 붙여져 있다. 이 도메인 계층은 .으로 구분하며 오른쪽부터 왼쪽 순서로 상위에서 하위이다.
- 예를 들면 www.naver.com은 com 도메인 아래에 &rarr; naver 도메인이 있고, 그 아래에 &rarr; www 도메인이 있는 것

하위 도메인의 DNS 서버 IP는 상위 도메인의 DNS 서버에 저장된다. 그래서 역순으로 내려가면서 위치를 찾을 수 있도록 되어 있다.  
가장 최상위 도메인은 루트 DNS 서버로, 탐색의 시작이 되는 가장 최상위 시작점 DNS 서버이다. 이 서버는 TLD 서버들의 위치만 알고 있다.

#### 담당 DNS 서버를 찾아 IP 주소를 가져온다
1. 클라이언트에서 DNS 서버로 설정되어 있는 주소로, www.lab.glasscom.com 이라는 웹 사이트를 조회하겠다고 요청
2. 그렇게 요청한 가장 가까운 DNS 서버에는 이름이 등록되어 있지 않기 때문에 도메인의 계층을 따라서 찾기 시작
3. 루트 도메인(루트 DNS 서버) 서버의 주소는 지금 DNS 서버에 저장되어 있기 때문에, 루트 도메인으로 www.lab.glasscom.com 의 IP 주소가 무엇인지 물어보는 요청을 전송
4. 루트 도메인 서버에도 해당 이름은 없지만 여기에는 com 도메인의 주소가 있으므로, 해당 주소로 안내한다.
5. 여기에도 역시 원하는 답은 없지만, com 도메인은 glasscom.com 도메인 서버의 주소를 알고 있기 때문에, 다시 해당 주소로 안내한다.
6. 이를 반복하여 최종적으로 해당 웹 사이트의 IP 주소를 찾게 된다.

#### DNS 서버는 캐시 기능을 사용한다
DNS 서버는 조회해 온 정보를 캐시에 저장해서 사용하기 때문에 이를 이용하여 좀 더 빠르게 IP 주소를 찾을 수 있게 된다.

### story4. 프로토콜 스택에 메시지 송신을 의뢰한다
이제 보내야 하는 IP 주소를 알게 되었으므로, 해당 IP를 가진 웹 서버로 리퀘스트 메시지를 보내도록 OS에 의뢰하게 된다.  
클라이언트와 서버는 각 프로토콜 스택(TCP)을 이용하여 소켓을 서로 연결하고 이 연결을 통해 데이터를 주고 받는다.

이 과정은..
1. 서버가 소켓을 열어두고 연결되기를 기다리고 있다.
2. 클라이언트도 소켓을 만들어서 서버 소켓에 연결한다. 마치 둘 사이에 파이프가 있는 것처럼 연결!
3. 이 파이프를 통해 데이터를 주고 받는다.
4. 할 일이 끝나면 파이프를 분리하고, 소켓을 삭제

한 단계씩 좀 더 자세하게 알아보자

#### 소켓은 어떻게 작성되는가?
DNS 서버로 요청을 보냈던 것처럼 Socket 라이브러리의 부품을 호출함으로서 작성이 시작된다. 다만 리졸버가 아닌 목적에 맞는 다른 부품을 호출하는 것 뿐이다.

- 소켓 생성을 위해 Socket 라이브러리의 socket 부품 호출 &rarr; socket 내부로 제어권이 넘어가고 소켓을 만들어 준다. (생성에 관한 자세한 내용은 2장!)
- 소켓이 생겼으면 소켓을 식별하기 위한 역할을 하는 `디스크립터`라는 것이 돌아온다. 여러 개의 소켓이 하나의 컴퓨터 안에 존재할 수 있기에, 이를 통해 소켓을 식별한다.

#### 파이프를 연결하는 접속 단계
브라우저는 만들어진 소켓을 서버 쪽 소켓에 연결할 수 있도록 프로토콜 스택에게 의뢰한다. Socket 라이브러리의 connect 부품을 호출하여 진행된다.  
이 때 필요한 3가지 값이 있다.
- 디스크립터 &rarr; 이 값을 보고 어떤 소켓을 접속에 이용할 것인지를 판단한다.
- 대상 IP 주소 &rarr; 접속을 시도해야 하는 것이 어떠한 컴퓨터인가를 판단한다. 이것을 보고 네트워크 상의 어떠한 컴퓨터로 가야 하는가를 확인.
- 포트 번호 &rarr; 컴퓨터까지는 찾아냈고, 이제 접속할 소켓을 찾아야 하는데, IP 주소만으로는 소켓을 알 수 없다. 따라서 포트 번호로 어느 소켓과 접속해야 하는지 지정해줘야 한다.

디스크립터는 내부에서 소켓을 식별하기 위한 장치이고, 포트 번호는 외부에서 접속하는 측이 소켓을 식별할 수 있도록 하기 위해 사용되는 장치이다.  
포트 번호는 미리 전 세계적으로 용도에 따라 결정되어 있는 번호를 따른다. 마치 웹 서버의 소켓은 80번을 쓰자! 와 같이.

접속 단계에서는 그렇게 서버와 연결하게 되면, 프로토콜 스택이 우리 소켓에 상대의 정보(IP,포트번호 등)를 저장한다.

#### 메시지를 주고 받는 송 수신 단계
연결이 완료되면 브라우저는 보낼 리퀘스트 메시지와 디스크립터 정보를 가지고 Socket 라이브러리의 write 부품을 이용해서 프로토콜 스택에게
송신을 의뢰한다.  
그러면 프로토콜 스택은 기록된 정보를 가지고 그 쪽으로 데이터를 송신하게 되고, 받은 쪽에서는 데이터 수신 동작이 일어나서 받은 데이터에 대해 적절하게 처리 후 응답한다.

다음으로는 우리 클라이언트가 이 응답 데이터를 수신해야 하는데, Socket 라이브러리의 read 부품을 통해 진행한다.
브라우저는 이 응답 데이터를 저장하기 위해 특정 메모리 지역을 지정해놓는데, 이곳을 `수신 버퍼`라고 하고, 돌아온 응답이 이 장소에 저장되게 된다.

#### 마지막 단계 연결 끊기
데이터를 서로 주고 받았다면, 이제 연결을 종료해야 한다. 브라우저는 Socket 라이브러리의 close 부품을 통해 연결을 종료하도록 의뢰한다.

어플리케이션의 종류에 따라 클라이언트와 웹 중 어느쪽이 먼저 연결을 끊을 것인지에는 차이가 있지만,
HTTP 프로토콜에서는 웹 서버가 송신 메시지를 완료했을 때 close로 연결을 끊고 클라이언트가 이를 확인하여 본인의 소켓도 연결 끊기 단계로 들어간다.
