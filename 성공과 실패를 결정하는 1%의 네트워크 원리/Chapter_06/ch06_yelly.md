# story 01 서버의 개요
## 1 클라이언트와 서버의 차이점
- 서버측 Socket 라이브러리는 `접속 대기` 상태
- 서버측 애플리케이션은 동시에 여러 클라이언트와 대화함

## 2 서버 애플리케이션 구조
### 접속을 기다리는 부분
- 새 클라이언트가 접속할 때마다 접속 동작을 수행

### 클라이언트와 대화하는 부분
- 접속이 완료된 클라이언트와 대화
- 대화가 끝나면 연결을 끊고 소켓을 종료

## 3 서버측의 소켓과 포트 번호
- TCP 는 다양한 형태로 데이터를 교환하는 구조
    - 좌우 대칭으로 데이터를 교환
    - 접속 동작만 좌우 대칭이 아님. 한 쪽은 접속 시도를 다른 한 쪽은 접속 대기를 함.
- 패킷이 도착하지 않아도 `accept()` 를 호출
  => 접속 대기 상태에서 패킷이 도착하면 그 떄 접수 동작을 하기 때문.

### 클라이언트와 접속 동작 상세 설명
- 클라이언트로부터 접속 패킷이 도착하면 `접속 대기` 상태의 소켓을 **복사**해서 **새로운 소켓**으로 만든다.
    - 대기 중인 소켓을 접속해버리면 다른 클라이언트의 접속은 못하게 되기 떄문.
- 새로운 소켓은 기존 소켓과 포트 번호가 똑같다.
- 소켓끼리 구분하는 법은 `<클라이언트 IP> + <클라이언트 Port 번호> + <서버 IP> + <서버 Port 번호>` 4개로 구분한다.

# story 02 서버의 수신 동작
## 1 LAN 어댑터에서 수신 신호를 디지털 데이터로 변환한다
- LAN 을 흐르는 패킷의 프리앰블 부분을 통해 클록이 어느 위치에 있는지 알아낸다.
- 클록을 같은 간격으로 연장하고 클록의 위치에서 신호의 방향(플러스 전압과 마이너스 전압)을 잡아낸다. => 디지털 데이터로 변환
    - 플러스 -> 마이너스 전압은 0, 마이너스 -> 플러스 전압은 1로 변환
- FCS(프레임 체크 시퀀스) 값과 비교해서 일치하지 않으면 버리고, 일치하면 LAN 어댑터 내부의 버퍼 메모리에 저장한다.
- `인터럽트`를 보내 CPU 에게 알린다.
- CPU 는 `LAN 드라이버`를 실행해 버퍼 메모리에 있는 패킷을 추출한다.
- `LAN 드라이버`는 MAC 헤더를 분석해 프로토콜 타입을 확인하고, 프로토콜을 처리할 수 있는 소프트웨어를 호출한다.
    - IP 프로토콜이면 TCP/IP 프로토콜 스택을 호출하고 패킷을 건넨다.

## 2 IP 담당 부분의 수신 동작
- IP 헤더가 올바른지 검사한다.
- 수신처 IP가 자신을 가리키는지 확인한다.
    - 자신의 IP와 달라도 라우터처럼 패킷을 중계하도록 된 IP 담당(서버용 OS)이라면 라우터처럼 패킷을 중계한다.
- 조각 나누기(패킷 분할)에 의해 패킷이 분할되어있는지 조사한다.
    - 분할된 패킷이라면 패킷 조각을 임시 메모리에 저장하고, 모두 도착하면 패킷을 조립한다.
- 프로토콜 번호에 따라 각 담당에게 전달한다.
    - 06: TCP / 11: UDP

## 3 TCP 담당 부분이 접속 패킷을 수산했을 때의 동작
- 도착한 패킷의 TCP 헤더를 조사한다.
    - 수신처 포트 번호에 해당하는 접속 대기중인 소켓을 확인한다.
        - 소켓이 없으면 클라이언트에 오류 통지 패킷을 반송한다.
        - 소켓이 있으면 소켓을 복사해서 새로운 소켓을 만들고, 여기에 클라이언트 IP, Port 반호, 서버 IP, Port 번호 등을 기록한다.
        - 송신 버퍼 또는 수신 버퍼로 쓰이는 메모리 영역을 확보한다.
    - 시퀀스 번호 초기값, 윈도우 값 등을 기록한 TCP 헤더를 만들고 IP 담당에게 의뢰해서 클라이언트에 반송한다.

## 4 TCP 담당 부분이 데이터 패킷을 수신했을 때의 동작
- 도착한 패킷(HTTP 메시지)을 처리할 소켓을 찾는다.
    - 클라이언트 IP, Port 번호, 서버 IP, Port 번호 4가지로 찾는다.
- 도착한 패킷의 TCP 헤더에 있는 `시퀀스 번호`와 `다음 시퀀스 번호`의 값과 일치하는지 확인한다.
    - `다음 시퀀스 번호`의 값은 이전 패킷의 데이터 길이(혹은 소켓에 기록된 시퀀스 번호)로부터 계산한다.
- 데이터 조각을 수신 버퍼에 저장 => 이전에 수신한 데이터 조각과 연결
- 이렇게 수신 버퍼에 저장하면 수신 확인용 TCP 헤더를 만든다.
    - 수신 패킷의 시퀀스 번호와 데이터 길이로부터 ACK 번호를 기록하고 IP 담당에게 의뢰하여 클라이언트에 반송한다.
- 애플리케이션이 수신 버퍼의 데이터를 가져가기 전까지(read() 호출 전까지) 데이터를 보관

## 5 TCP 담당 부분의 연결 끊기 동작
- HTTP 1.0 이라면 서버에서 연결 끊기 동작을 실행
- Socket 라이브러리의 close() 를 호출한다.
- TCP 담당이 FIN = 1 로 설정한 TCP 헤더를 만들고, IP 담당에게 의뢰하여 클라이언트에 보낸다.
- 클라이언트가 이걸 받으면 ACK = 1 을 반송한다.
- 클라이언트도 close() 를 호출하고 FIN = 1 로 설정한 TCP 헤더를 서버에게 보낸다.
- 서버가 ACK = 1 를 반송하면 서버와 클라이언트 모두 연결 끊기 동작은 끝난다. (완전히 끊긴건 아님)
- 연결 끊기 동작이 끝나고 잠시 기다렸다가 소켓을 말소한다.

# story 03 웹 서버 소프트웨어가 리퀘스트 메시지의 의미를 해석하여 요구에 응한다
## 1 조회의 URI 를 실제 파일명으로 변환한다
- 웹 서버에서 공개하는 디렉토리는 디스크의 실제 디렉토리가 아닌 가상으로 만든 디렉토리다.
- URI 의 경로명이 파일명을 생략한 형태인 경우 서버에 미리 설정된 파일명이 있는것으로 간주한다.

## 2 CGI 프로그램을 작동한 경우
- URI 에 동작시킬 프로그램 파일의 이름을 쓴 경우가 있다.
- 이 떄 프로그램이 실행되고, 실행된 결과(출력 데이터)를 응답한다.

## 3 웹 서버로 수행하는 액세스 제어
- 클라이언트 IP 주소에 따라 동작을 제어할 수 있다.
    - IP 주소만 검사한다.
- 클라이언트 도메인명에 따라 동작을 제어할 수 있다.
    - DNS 서버를 이용한다.
- 사용자명과 패스워드에 따라 동작을 제어할 수 있다.
    - 클라이언트는 Authorization 해더에 정보를 기입해서 인증한다.

## 4 응답 메시지를 되돌려 보낸다
- 응답 메시지는 클라이언트의 접속된 소켓 정보(디스크립터)를 통지한다.
- 프로토콜 스택은 한 개의 패킷에 들어가는 길이로 데이터를 분할하고, 헤더를 붙여 패킷을 송출한다.

# story 4 웹 브라우저가 응답 메시지를 받아 화면에 표시한다
## 1 응답 데이터의 형식을 보고 본질을 판단한다
- 데이터의 종류는 문장, 화상, 음성, 영상 등이 있다.
- 어떤 종류인지는 `Content-Type` 헤더로 판단한다.
    - 데이터 종류를 나타내는 `MIME(Multipurpose Internet Mail Extensions)` 이라는 스펙이 있음
    - text/html 예에서 `/` 왼쪽은 메인 타입(대분류), 오른쪽은 서브 타입(실제 데이터 종류)
    - 데이터가 **텍스트**면 문자 코드를 나타내는 charset=utf-8; 같은 부가 정보를 추가
- `Content-Type` 헤더 조사 후엔 `Content-Encoding` 헤더를 조사
    - 압축 기술이나 부호화 기술에 대한 힌트
### Content-Encoding 이란?
- 서버가 클라이언트에 데이터를 전달하기 전에 압축하거나 인코딩했음을 나타낸다.
  - image/jpeg 타입의 파일은 이미 인코딩된 상태기 때문에 따로 인코딩하지 않음. (압축해봤자 성능 차이가 미미하고 괜히 압축하느라 cpu 자원을 더씀)
- 클라이언트(브라우저)는 이 헤더를 보고 압축된 데이터를 해제(또는 디코딩)해서 원본 데이터로 복원한다.
- 자주 사용되는 인코딩 방식
  - **gzip**: 가장 많이 사용. 높은 압축률과 높은 압축 해제 속도를 제공 => 웹 페이지 로드 속도를 높임
  - **br**: HTTP/2 와 함께 사용하기 위해 최적화 됨. 최근에 많이 사용되는 압축 알고리즘. gzip 보다 더 나은 압축률을 제공할 수도 있음.
  - **zstd**: facebook 에서 개발한 압축 알고리즘. gzip, br 보다 매우 빠르고 높은 압축률 제공. 대규모 데이터에 적합. 모든 브라우저에서 호환x
  - deflate: gzip 과 유사함. (덜 호환됨)
  - compress: 현재 거의 사용되지 않음.
  - identify: 압축 안함.

## 2 브라우저 화면에 웹 페이지를 표시하여 액세스를 완료한다
- HTML 문서, 일반 텍스트 같은 데이터를 브라우저에서 표시한다.

### HTML 문서를 표시하는 경우
- 태그에 있는 정보를 해석해서 화면에 표시한다.
- 그런데 실제 화면은 OS 가 담당한다.
    - OS 에게 어떤 위치에 어떤 문자, 글꼴 등을 표시하도록 지시하는 것임.
- `.htm` 확장자 파일이 HTML 내에 있다면, 브라우저는 화상 데이터 파일을 서버에서 읽고 태그가 있던 곳에 화상 데이터를 내장시킨다.
    - gif, jpeg 형식의 화상 데이터는 압축을 풀고나서 OS 에게 데이터를 전달한다.
- 워드 파일이나 ppt 파일은 브라우저에서 표시할 수 없으므로 해당 애플리케이션을 직접 호출
    - 브라우저 내 플러그인 형태거나 독립된 프로그램
