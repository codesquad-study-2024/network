## story 01. 서버의 개요
### 1. 클라이언트와 서버의 차이점
웹 서버는 서버가 기동된 이후 여러 준비 동작을 거쳐 연결을 기다리는 상태가 되고, 클라이언트로부터 패킷을 받아 처리하게 된다.

#### 서버 vs 클라이언트
서버 머신은 용도에 따라 다양한 종류가 존재하며, 하드웨어나 OS 부분에 있어서 클라이언트와 다른 종류도 존재한다.

이런 머신의 종류마다 모두 다른 네트워크 스펙을 사용한다면 서로 통신에 문제가 되기 때문에, 서버들 뿐 아니라 
서버와 클라이언트도 기본적으로 네트워크에 관한 부분들(LAN 어댑터, 프로토콜 스택 등등)은 모두 동일하다.  

하지만 접속 동작에서 서버와 클라이언트가 수행하는 역할이 다르므로 서버 어플리케이션과 클라이언트 어플리케이션은
구조가 다를 수 밖에 없다.  
&rarr; 클라이언트는 접속 동작을 수행하고, 서버는 클라이언트의 접속 동작을 기다린다.

### 2. 서버 어플리케이션의 구조
하나의 서버는 동시의 여러 클라이언트와 통신 동작을 실행한다. 하지만 하나의 프로그램으로 동시에 여러 클라이언트들과 통신하는 것은 어려운 일이다.  
따라서 클라이언트가 서버에 접속할 때마다, 새로 서버 프로그램을 작동시켜 서버와 클라이언트가 1:1로 통신하도록 하는 것이 일반적이다.

![스크린샷 2024-08-20 오전 1 35 07](https://github.com/user-attachments/assets/cabc2ecb-6339-423a-8b12-2797a5e630af)

간단하게는 다음과 같은 순서로 진행된다.
1. 서버 프로그램이 작동되면 설정 파일 읽기 등의 초기화 작업을 마치고, 접속을 기다리는 부분을 실행한다.
2. 접속을 기다리는 부분은 접속을 위해 소켓을 작성하고, 클라이언트의 접속 동작을 기다리는 상태로 만든다.
3. 접속 동작을 기다리고 있는 서버 소켓은 클라이언트가 접속하게 되면 접속 과정을 진행한다.
4. 정상적으로 접속 과정이 끝나면, 클라이언트와 대화하는 부분을 작동시켜 접속이 끝난 소켓을 건내준다.
5. 해당 소켓을 통해 서버와 클라이언트는 통신을 주고 받는다.
6. 모든 통신이 끝난 이후에는 연결을 끊고 종료한다.

이 때 클라이언트와 대화하는 부분은 새로운 클라이언트의 요청이 들어올 때 마다 새롭게 소켓이 생성되어 연결되게 되는데,
멀티태스크, 멀티스레드 기능이 이를 가능하게 만들어 준다.

### 3. 서버측의 소켓과 포트 번호
데이터의 송,수신에 있어 서버와 어플리케이션이라는 역할을 한정해 두지 않고 양쪽 다 데이터를 송신할 수 있도록 하는 것이 TCP의 동작 배경인데,
한 가지 `접속 동작`이라는 부분만은 접속하는 측과, 기다리는 측이라는 역할 분담이 필요하다.

이런 시점에서 보았을 때 접속하는 측이 클라이언트, 접속을 기다리는 쪽이 서버가 되고, 동작에서 차이가 발생한다.

#### 클라이언트의 접속 동작
1. 소켓 작성
2. 서버측의 소켓과 파이프로 접속
3. 데이터를 송, 수신
4. 파이프를 분리 후 소켓 말소하여 연결 끊기

#### 서버측의 접속 동작
서버측의 접속 동작에 대해서는 좀 더 자세하게 살펴보자
1. `socket`을 호출하여 소켓을 생성하고 특정 포트 번호를 소켓과 `bind`한다.
2. `listen`을 통해 접속을 대기하는 역할을 하는 소켓으로 설정한다.
3. `accept`를 호출, 비로소 접속 패킷이 도착하기를 기다리는 blocking 상태가 된다.
4. 이 상황에서 클라이언트 측으로부터 패킷이 도착하면, 접수 동작을 진행하고 `accept`가 완료되면서 새로운 소켓이 만들어진다.
이 소켓은 접속 대기 소켓이 복사되어 만들어지며, 여기에는 접속 상대인 클라이언트의 정보를 비롯한 제어 정보가 기록된다.
5. 이렇게 만들어진 소켓을 클라이언트와 대화하는 부분에 전달하고 데이터 송, 수신 동작이 일어난다.

#### 접속 대기 상태의 소켓에 관하여
이렇게 접속을 위해 새로운 소켓이 만들어지더라도 접속 대기 상태의 소켓은 계속해서 접속을 위해 `accept`를 호출하며 대기한다.
그러다 또 새로운 연결 요청이 오면 자신을 복사하여 새로운 소켓을 만들고, 새로운 태스크에 전달하는 것을 반복하는 것이다.

> 이런 식으로 접속 대기 소켓은 유지되고 자신을 복사하는 식으로 작동하는 이유는 송,수신을 종료하면 해당 소켓이 말소된다는 것에 있다.  

만일 새 소켓을 만드는 것이 아니라 이 접속 대기 소켓을 사용하는 경우, 송,수신이 종료된 이후에 소켓이 사라져버리게 된다.
따라서 다음 클라이언트가 접속할 수 없으면 곤란하므로, 새로운 소켓을 만들어서 사용하는 것이다.

#### 서버측 소켓의 포트 번호 구분하기
이렇게 새 소켓이 만들어질 때 앞서 제어 정보가 기록된다고 했다. 이 과정에서 소켓에 포트 번호가 할당된다.  
여기서 포트 번호라는 것은 소켓을 구분하기 위해 필요한 정보이다. 그렇기 때문에 소켓마다 다른 포트 번호를 가져야 하는 것이 상식적일 것이다.

> 접속 대기 상태의 소켓이 80번이라고 가정할 때, 당연히 해당 소켓은 80번으로 들어오는 요청을 처리하게 될 것이다.
> 그리고 이 과정에서 대기 소켓은 자기 자신을 복사하여 실제 접속 과정을 담당할 소켓을 만든다. 그렇다면 이 소켓의 포트번호는 어떻게 설정해야 할까?

![스크린샷 2024-08-20 오전 3 17 01](https://github.com/user-attachments/assets/36de473c-e118-480f-9fe0-137864657091)

- **먼저 80번 포트가 이미 있으므로 실제 접속 소켓은 포트 번호를 다르게 설정한다고 가정하자**
    - 클라이언트에게 응답을 보내는 것은 실제 접속 소켓이므로 제어 정보에는 이 소켓의 포트 번호가 기록된다.
  즉, 클라이언트 입장에서는 80번 포트로 요청을 보냈는데 엉뚱한 포트번호에서 응답이 돌아오는 상황이 된다.
    - 이렇게 되면 클라이언트가 이것이 올바르게 회신된 응답 패킷인지 판별할 수 없으므로, 우리는 실제 접속 포트에도 포트 번호를
  동일하게 할당해주어야 한다.

![스크린샷 2024-08-20 오전 3 17 17](https://github.com/user-attachments/assets/11b97f9c-2058-47ef-bd0f-bff98fe5de49)

- **이렇게 설정하는 경우 동일한 포트를 가진 여러 개의 소켓이 생기는 문제가 생긴다**
  - 근본적으로 포트번호는 소켓을 구별하기 위한 목적을 가진다고 했다. 그런데 지금은 동일한 포트를 가진 여러 개의 소켓이 있어
  포트번호만으로 어떤 소켓에 패킷을 보내야 하는지를 알 수 없다.
  - 이를 해결하기 위해서는 클라이언트의 ip주소와 포트 번호를 함께 식별자로 사용하면 된다.
  - 클라이언트에서도 요청을 보낼 때 사용하는 소켓에 할당된 포트 번호가 존재하고, 이는 서버의 소켓 다르게 하나의 포트 번호만이 존재한다.
  > 클라이언트에서는 요청을 대기하고 소켓을 복사하고 이러한 것이 전혀 필요가 없고 그저 요청에 대한 응답을 잘 주고받기만 하면 되기 때문에
  > 정해진 범위 내에서 지금 열려 있는 포트 번호와 겹치지 않는 번호가 내부 규칙대로 할당된다.
  - 결론적으로 서버,클라이언트의 ip 주소와 포트번호라는 4가지 정보를 사용해서 어떤 소켓과 통신을 연결해야 하는지를 알 수 있게 된다.

![스크린샷 2024-08-20 오전 3 17 27](https://github.com/user-attachments/assets/63837399-ef77-4978-93c5-20519d78c93a)

#### 소켓 식별에 디스크립터를 사용하는 이유
위에서 저 4가지 정보로 소켓을 식별할 수 있음을 알아보았다. 그런데 OS는 왜 소켓을 식별하는데 있어 따로 디스크립터를 사용하고 있을까?

- 소켓이 만들어진 직후부터 운영체제는 이 소켓들을 식별해야 하는데, 이 시점에서는 접속하지 않은 상태이기 때문에 클라이언트 측 정보를 알 수 없다.
- 만약 이것이 가능하다고 할지라도 간단하게 소켓을 식별할 수 있는 디스크립터(일반적으로 정수)가 4가지 정보보다 간단하고 효율적이다